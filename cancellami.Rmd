---
title: "gapminder-wrangle"
author: "Serena"
date: "16 aprile 2020"
output: html_document
---

## Wrang gapminder data using dplyr
####ctrl + shift+ m shortcut per %>% 
We will use the read_csv() function from the readr package

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)


## read gapminder csv. Note the readr:: prefix identifies which package it's in
gapminder <- readr::read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv') 

head(gapminder) # shows first 6
tail(gapminder) # shows last 6

head(gapminder, 10) # shows first X that you indicate
tail(gapminder, 12) # guess what this does!
```

```{r}
str(gapminder) # ?str - displays the structure of an object
```
```{r}
names(gapminder)
dim(gapminder)    # ?dim dimension
ncol(gapminder)   # ?ncol number of columns
nrow(gapminder)   # ?nrow number of rows
```
```{r}
summary(gapminder)


library(skimr) # install.packages('skimr')
skim(gapminder)
```

```{r}
knitr::include_graphics("img 1.png") ##per includere immagini
```

```{r}
head(gapminder)

```
What was the average life expectency in Brazil between 1987 and 2007?

```{r}
br<-filter(gapminder, country=="Brazil")
mean(br$lifeExp)
```

I’ve advised you to think “gets” whenever you see the assignment operator, <-. Similarly, you should think “and then” whenever you see the pipe operator, %>%.

###Exercise 1

Calculate the population in thousands for all Asian countries in the year 2007 and add it as a new column.

Then, sync to Github.com (pull, stage, commit, push).
```{r}
gapminder %>% 
          filter(continent=="Asia", year==2007 ) %>%
          mutate(pop_thousand=pop/1000)  %>%
          select(country, year, pop_thousand) #this cleans up the database byt isn't necessary
          

```

*What is the maximum GDP per continent across all years?
```{r}
gapminder%>%
  mutate(gdp=pop*gdpPercap)%>%  #adds new variables
  group_by(continent)     %>%
  mutate(max_gdp= max(gdp))%>%
  filter(gdp==max_gdp)

```

1. arrange your data frame in descending order (opposite of what we’ve done). Expect that this is possible: ?arrange
2. save your data frame as a variable
3. find the maximum life expectancy for countries in Asia. What is the earliest year you encounter? The latest? Hint: you can use or base::max and dplyr::arrange()…

Knit your RMarkdown file, and sync it to GitHub (pull, stage, commit, push)
```{r}
asia_lifexp<-gapminder%>%
  filter(continent=="Asia")%>%
  group_by(country)%>%
  filter(lifeExp==max(lifeExp))%>%
  arrange(year)
```

+dplyr allow you to filter() by rows and select() by columns, create new columns with mutate(), and group_by() unique column values to apply summarize() for new columns that define aggregate values across groupings.

```{r}
gap_wide<-readr::read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder_wide.csv')

str(gap_wide)
head(gap_wide)

```
```{r}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values)
str(gap_long)
tail(gap_long)
?gather
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         dplyr::starts_with('pop'),
         dplyr::starts_with('lifeExp'),
         dplyr::starts_with('gdpPercap'))  #here i'm listing all the columns to use in gather

str(gap_long)
head(gap_long)
tail(gap_long)
```
```{r}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         -continent, -country) %>%
  separate(obstype_year,
           into = c('obs_type','year'),
           sep = "_",
           convert = TRUE) #this ensures that the year column is an integer rather than a character

head(gap_long)
tail(gap_long)
```


```{r}
canada_df <- gap_long %>%
  filter(obs_type == "lifeExp",
         country == "Canada")

ggplot(canada_df, aes(x = year, y = obs_values)) +
  geom_line()
```

Using gap_long, calculate and plot the the mean life expectancy for each continent over time from 1982 to 2007. Give your plot a title and assign x and y labels. Hint: do this in two steps. First, do the logic and calculations using dplyr::group_by() and dplyr::summarize(). Second, plot using ggplot().

```{r}
mean_life_ext<-gap_long %>% 
  filter(obs_type=="lifeExp", year>1980) %>% 
  group_by(continent, year) %>% 
  summarize(mean_le=mean(obs_values)) %>% 
  ungroup()  #removes the grouping and it’s good to get in the habit of using it after a     group_by()
mean_life_ext

library(ggplot2)
ggplot(data=mean_life_ext, aes(x=year, y=mean_le, color=continent))+
         geom_line()+
  labs(title="Mean life Expectancy",
    x="Years", y="Mean")



## Additional customization
ggplot(data = continents, aes(x = year, y = mean_le, color = continent)) + 
  geom_line() +
  labs(title = "Mean life expectancy",
       x = "Year",
       y = "Age (years)",
       color = "Continent") +
  theme_classic() +
  scale_fill_brewer(palette = "Blues")  


# solution (no peeking!)
continents <- gap_long %>% 
  filter(obs_type == "lifeExp", 
         year > 1980) %>% 
  group_by(continent, year) %>% 
  summarize(mean_le = mean(obs_values)) %>%
  ungroup()

ggplot(data = continents, aes(x = year, y = mean_le, color = continent)) + 
  geom_line() +
  labs(title = "Mean life expectancy",
       x = "Year",
       y = "Age (years)") 

## Additional customization
ggplot(data = continents, aes(x = year, y = mean_le, color = continent)) + 
  geom_line() +
  labs(title = "Mean life expectancy",
       x = "Year",
       y = "Age (years)",
       color = "Continent") +
  theme_classic() +
  scale_fill_brewer(palette = "Blues")  

```



```{r}
gap_normal <- gap_long %>% 
  spread(obs_type, obs_values)

dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
```



>7.6 Exercise
Convert gap_long all the way back to gap_wide. Hint: Do this in 2 steps. First, create appropriate labels for all our new variables (variable_year combinations) with the opposite of separate: tidyr::unite(). Second, spread() that variable_year column into wider format.

Knit the R Markdown file and sync to Github (pull, stage, commit, push)
```{r}
str(gap_long)
str(gap_wide)
gap_wide2<-gap_long %>% 
unite(col=var_names,obs_type, year, sep="_") %>% 
spread(key = var_names, value = obs_values)
str(gap_wide2)


head(gap_long) # remember the columns

gap_wide_new <- gap_long %>% 
  # first unite obs_type and year into a new column called var_names. Separate by _
  unite(col = var_names, obs_type, year, sep = "_") %>% 
  # then spread var_names out by key-value pair.
  spread(key = var_names, value = obs_values)
str(gap_wide_new)
```





```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
